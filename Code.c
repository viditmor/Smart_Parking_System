#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Structure to store vehicle details
struct Vehicle {
    char vehicle_number[20]; // Vehicle registration number
    char owner_name[100]; // Owner's name
    time_t arrivaltime; // Arrival time of the vehicle
    time_t departtime; // Departure time of the vehicle
    float totalparking_hours; // Total parking hours used by the vehicle
    int parkingID; // ID of the allocated parking space
    float Revenue; // Total revenue generated from this vehicle
    int no_of_Parking; // Number of times this vehicle has parked
    int isParked; //parked or not
    struct Vehicle* next; // Pointer to the next vehicle in the linked list
};

// Structure to store parking space details
struct ParkingSpace {
    int spaceID; // Unique ID for the parking space
    int isOccupied; // Status of parking space (1 if occupied, 0 if not)
    float revenueGenerated; // Revenue generated by this parking space
    int occupancy; // Number of times this parking space has been used
    struct ParkingSpace* next; // Pointer to the next parking space in the linked list
};

struct Vehicle* vehicleHead = NULL; // Head pointer for vehicle linked list
struct ParkingSpace* parkingHead = NULL; // Head pointer for parking space linked list

// Function to initialize parking spaces as a linked list
void initializeParkingSpaces() {
    struct ParkingSpace* temp = NULL;
    for(int i = 50; i > 0; i--) { // Creating 50 parking spaces
        struct ParkingSpace* newSpace = (struct ParkingSpace*)malloc(sizeof(struct ParkingSpace));
        newSpace->spaceID = i; // Assign space ID
        newSpace->isOccupied = 0; // Mark as not occupied
        newSpace->revenueGenerated = 0.0f; // No revenue initially
        newSpace->occupancy = 0; // No occupancy initially
        newSpace->next = temp; // Link to the previous node
        temp = newSpace; // Move temp to the new node
    }
    parkingHead = temp; // Assign the head of parking spaces list
}

// Function to save vehicle data to a file with descriptive labels
void saveVehicleDataToFile() {
    FILE* file = fopen("vehicle.txt", "w"); // Open file for writing
    if (file == NULL) {
        printf("Error opening file for writing.\n");
        return;
    }

    struct Vehicle* temp = vehicleHead;
    while (temp != NULL) { // Traverse through the linked list
        fprintf(file, "%s %s %ld %ld %.2f %d %.2f %d %d\n", 
                temp->vehicle_number,
                temp->owner_name,
                temp->arrivaltime,
                temp->departtime,
                temp->totalparking_hours,
                temp->parkingID,
                temp->Revenue,
                temp->no_of_Parking,
                temp->isParked);
        temp = temp->next;
    }

    fclose(file); // Close the file
}


// Function to load vehicle details from file
void loadVehicleDataFromFile() {
    FILE* file = fopen("vehicle.txt", "r"); // Open file for reading
    if (file == NULL) {
        printf("No previous data found.\n");
        return;
    }

    while (1) {
        struct Vehicle* newVehicle = (struct Vehicle*)malloc(sizeof(struct Vehicle));
        if (newVehicle == NULL) {
            printf("Memory allocation failed.\n");
            break;
        }

        // Read data including isParked
        if (fscanf(file, "%s %s %ld %ld %f %d %f %d %d", 
                   newVehicle->vehicle_number, newVehicle->owner_name, 
                   &newVehicle->arrivaltime, &newVehicle->departtime, 
                   &newVehicle->totalparking_hours, &newVehicle->parkingID, 
                   &newVehicle->Revenue, &newVehicle->no_of_Parking, 
                   &newVehicle->isParked) != 9) {  // NEW FIELD ADDED
            free(newVehicle);
            break;
        }

        newVehicle->next = vehicleHead; // Insert into the linked list
        vehicleHead = newVehicle;
    }

    fclose(file); // Close the file
}

// Function to find parking space by ID
struct ParkingSpace* findParkingSpace_(int spaceID) {
    struct ParkingSpace* temp = parkingHead;
    while (temp != NULL) {
        if (temp->spaceID == spaceID) {
            return temp; // Return pointer if found
        }
        temp = temp->next;
    }
    return NULL; // Return NULL if not found
}

// Function to save parking space data to a file with descriptive labels
void saveParkingSpaceDataToFile() {
    FILE* file = fopen("parking_space.txt", "w"); // Open file for writing
    if (file == NULL) {
        printf("Error opening parking_space.txt for writing.\n");
        return;
    }
    
    struct ParkingSpace* temp = parkingHead;
    while (temp != NULL) { // Traverse the linked list
        fprintf(file,
                "Space ID: %d, Is Occupied: %d, Revenue Generated: %.2f, Occupancy: %d\n",
                temp->spaceID,
                temp->isOccupied,
                temp->revenueGenerated,
                temp->occupancy);
        temp = temp->next;
    }
    
    fclose(file); // Close the file
}

// Function to load and update parking space data from a file with descriptive labels
void loadParkingSpaceDataFromFile() {
    FILE* file = fopen("parking_space.txt", "r"); // Open file for reading
    if (file == NULL) {
        printf("No previous parking space data found.\n");
        return;
    }

    while (1) {
        struct ParkingSpace tempSpace;
        
        // Read formatted data with labels
        if (fscanf(file, "Space ID: %d, Is Occupied: %d, Revenue Generated: %f, Occupancy: %d\n", 
                   &tempSpace.spaceID, &tempSpace.isOccupied, 
                   &tempSpace.revenueGenerated, &tempSpace.occupancy) != 4) {
            break; // Stop if data is not in correct format
        }

        struct ParkingSpace* existingSpace = findParkingSpace_(tempSpace.spaceID);
        if (existingSpace) {
            // Update existing parking space data
            existingSpace->isOccupied = tempSpace.isOccupied;
            existingSpace->revenueGenerated = tempSpace.revenueGenerated;
            existingSpace->occupancy = tempSpace.occupancy;
        } else {
            // Create a new parking space entry
            struct ParkingSpace* newSpace = (struct ParkingSpace*)malloc(sizeof(struct ParkingSpace));
            if (newSpace == NULL) {
                fprintf(stderr, "Memory allocation failed.\n");
                break;
            }
            
            *newSpace = tempSpace; // Copy data
            newSpace->next = parkingHead;
            parkingHead = newSpace; // Add to linked list
        }
    }

    fclose(file); // Close the file
}

// Function to find a vehicle in the linked list
struct Vehicle* findVehicle(char vehicleNumber[]) {
    struct Vehicle* temp = vehicleHead;
    while (temp != NULL) { // Traverse through the linked list
        if (strcmp(temp->vehicle_number, vehicleNumber) == 0)
            return temp; // Return vehicle if found
        temp = temp->next;
    }
    return NULL; // Return NULL if vehicle not found
}

// Function to find parking space based on total parking hours
struct ParkingSpace* findParkingSpace(float totalparkinghours) {
    struct ParkingSpace* temp = parkingHead;
    int start = 21;

    if (totalparkinghours >= 200.00) {
        start = 1;
    } else if (totalparkinghours >= 100.00) {
        start = 11;
    }

    while (temp != NULL) {
        if (temp->spaceID >= start && temp->isOccupied == 0) {
            return temp;
        }
        temp = temp->next;
    }
    return NULL;
}

// Function to park a vehicle
void parkVehicle(char vehicleNumber[], char ownerName[]) {
    time_t currentTime;
    time(&currentTime);
    struct Vehicle* vehicle = findVehicle(vehicleNumber);

        // If the vehicle is found and is already parked, prevent re-parking
        if (vehicle != NULL && vehicle->isParked == 1) {
            printf("This vehicle is already parked.\n");
            return;
        }

    struct ParkingSpace* space = findParkingSpace(vehicle ? vehicle->totalparking_hours : 0);
    if (space == NULL) {
        printf("No parking space available.\n");
        return;
    }

    if (vehicle == NULL) { // If vehicle is not found, create a new entry
        vehicle = (struct Vehicle*)malloc(sizeof(struct Vehicle));
        strcpy(vehicle->vehicle_number, vehicleNumber);
        strcpy(vehicle->owner_name, ownerName);
        vehicle->totalparking_hours = 0.0f;
        vehicle->Revenue = 0.0f;
        vehicle->no_of_Parking = 0;
        vehicle->isParked=1;
        vehicle->next = vehicleHead;
        vehicleHead = vehicle;
    }else{
        vehicle->isParked=1;
    }

    vehicle->arrivaltime = currentTime;
    vehicle->parkingID = space->spaceID;
    space->isOccupied = 1;
    space->occupancy += 1;
    vehicle->no_of_Parking += 1;
    saveVehicleDataToFile();
    saveParkingSpaceDataToFile();
    printf("Your allotted parking slot is %d\n", space->spaceID);
}

// Function to calculate parking payment
float calculatePayment(float parkedhours, float totalparkinghours) {
    float payment = 100.00;
    if (totalparkinghours < 100) {
        if (parkedhours <= 3) {
            return payment;
        } else {
            return payment + (parkedhours - 3) * 50;
        }
    } else {
        if (parkedhours <= 3) {
            return payment * 0.9;
        } else {
            return (payment + (parkedhours - 3) * 50) * 0.9;
        }
    }
}

// Function to handle vehicle exit
void exitVehicle(char vehicleNumber[]) {
    struct Vehicle* vehicle = findVehicle(vehicleNumber);
    if (!vehicle || vehicle->isParked==0) {
        printf("Vehicle not found.\n");
        return;
    }
    time_t currentTime;
    time(&currentTime);
    vehicle->departtime = currentTime;
    float parkedHours = difftime(vehicle->departtime, vehicle->arrivaltime) / 3600.0f;
    vehicle->totalparking_hours += parkedHours;
    float payment = calculatePayment(parkedHours, vehicle->totalparking_hours);
    vehicle->Revenue += payment;
    vehicle->isParked=0;
    printf("Your car has exited. Your payment: %.2f\n", payment);
    
    struct ParkingSpace* temp = parkingHead;
    while (temp != NULL) {
        if (temp->spaceID == vehicle->parkingID) {
            temp->isOccupied = 0;
            temp->revenueGenerated += payment;
            break;
        }
        temp = temp->next;
    }
    saveVehicleDataToFile();
    saveParkingSpaceDataToFile();
}
// Function to free a vehicle list
void freeVehicleList(struct Vehicle* head) {
    struct Vehicle* temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
}
// Function to create a copy of the vehicle list
struct Vehicle* copyVehicleList(struct Vehicle* head) {
    if (!head) return NULL;

    struct Vehicle* newHead = NULL;
    struct Vehicle* tail = NULL;
    
    struct Vehicle* current = head;
    while (current) {
        struct Vehicle* newVehicle = (struct Vehicle*)malloc(sizeof(struct Vehicle));
        if (!newVehicle) {
            printf("Memory allocation failed.\n");
            freeVehicleList(newHead);
            return NULL;
        }

        // Copy data
        strcpy(newVehicle->vehicle_number, current->vehicle_number);
        strcpy(newVehicle->owner_name, current->owner_name);
        newVehicle->arrivaltime = current->arrivaltime;
        newVehicle->departtime = current->departtime;
        newVehicle->totalparking_hours = current->totalparking_hours;
        newVehicle->parkingID = current->parkingID;
        newVehicle->Revenue = current->Revenue;
        newVehicle->no_of_Parking = current->no_of_Parking;
        newVehicle->isParked = current->isParked;
        newVehicle->next = NULL;

        // Add to new list
        if (!newHead) {
            newHead = newVehicle;
            tail = newVehicle;
        } else {
            tail->next = newVehicle;
            tail = newVehicle;
        }

        current = current->next;
    }

    return newHead;
}
// Function to free the copied list
void freeParkingList(struct ParkingSpace* head) {
    struct ParkingSpace* temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
}



// Function to create a deep copy of the linked list
struct ParkingSpace* copyParkingList(struct ParkingSpace* head) {
    if (!head) return NULL;

    struct ParkingSpace* newHead = NULL;
    struct ParkingSpace* newTail = NULL;

    struct ParkingSpace* current = head;
    while (current) {
        struct ParkingSpace* newNode = (struct ParkingSpace*)malloc(sizeof(struct ParkingSpace));
        if (!newNode) {
            printf("Memory allocation failed\n");
            return NULL;
        }
        // Copying data
        newNode->spaceID = current->spaceID;
        newNode->isOccupied = current->isOccupied;
        newNode->revenueGenerated = current->revenueGenerated;
        newNode->occupancy = current->occupancy;
        newNode->next = NULL;

        if (!newHead) {
            newHead = newNode;
            newTail = newNode;
        } else {
            newTail->next = newNode;
            newTail = newNode;
        }

        current = current->next;
    }
    return newHead;
}


// Function to split a linked list into two halves
struct Vehicle* split(struct Vehicle* head) {
    if (!head || !head->next) {
        return NULL;  // If list is empty or has only one element
    }
    struct Vehicle* slow = head;
    struct Vehicle* fast = head->next;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    struct Vehicle* mid = slow->next;
    slow->next = NULL;
    return mid;
}

// Function to merge_Parkingcount two sorted linked lists
struct Vehicle* merge_Parkingcount(struct Vehicle* left, struct Vehicle* right) {
    if (!left) return right;
    if (!right) return left;

    struct Vehicle* result = NULL;
    
    if (left->no_of_Parking > right->no_of_Parking) {  // Sorting in descending order
        result = left;
        result->next = merge_Parkingcount(left->next, right);
    } else {
        result = right;
        result->next = merge_Parkingcount(left, right->next);
    }
    
    return result;
}

// Merge Sort function for sorting vehicles
struct Vehicle* mergeSort_Parkingcount(struct Vehicle* head) {
    if (!head || !head->next) {
        return head;  // Base case: 0 or 1 elements
    }

    struct Vehicle* mid = split(head);
    struct Vehicle* left = mergeSort_Parkingcount(head);
    struct Vehicle* right = mergeSort_Parkingcount(mid);

    return merge_Parkingcount(left, right);
}

// Wrapper function to sort vehicles using merge_Parkingcount sort
void sortVehiclesByParkingCount() {
    struct Vehicle* copiedList = copyVehicleList(vehicleHead);  // Copy original list
    copiedList = mergeSort_Parkingcount(copiedList);  // Sort copied list

    // Display sorted vehicles
    struct Vehicle* temp = copiedList;
    printf("Vehicles sorted by parking count:\n");
    while (temp) {
        printf("Vehicle: %s | Parking Count: %d\n", temp->vehicle_number, temp->no_of_Parking);
        temp = temp->next;
    }

    freeVehicleList(copiedList);  // Free copied list
   
}

struct Vehicle* merge_revenue(struct Vehicle* left, struct Vehicle* right) {
    if (!left) return right;
    if (!right) return left;

    struct Vehicle* result = NULL;

    // Sorting in descending order by `Revenue`
    if (left->Revenue >= right->Revenue) {
        result = left;
        result->next = merge_revenue(left->next, right);
    } else {
        result = right;
        result->next = merge_revenue(left, right->next);
    }

    return result;
}

// Merge Sort function for sorting vehicles by revenue
struct Vehicle* mergeSort_Revenue(struct Vehicle* head) {
    if (!head || !head->next) {
        return head;  // Base case: 0 or 1 elements
    }

    struct Vehicle* mid = split(head);
    struct Vehicle* left = mergeSort_Revenue(head);
    struct Vehicle* right = mergeSort_Revenue(mid);

    return merge_revenue(left, right);
}

void sortAndDisplayVehiclesByRevenue() {
    struct Vehicle* copyHead = copyVehicleList(vehicleHead);  // Create a copy
    if (!copyHead) {
        printf("Failed to create a copy of the vehicle list.\n");
        return;
    }

    copyHead = mergeSort_Revenue(copyHead);  // Sort the copied list

    printf("\nSorted Vehicles by Revenue (Copy):\n");
    struct Vehicle* temp = copyHead;
    while (temp) {
        printf("Vehicle: %s | Owner: %s | Revenue: %.2f\n", temp->vehicle_number, temp->owner_name, temp->Revenue);
        temp = temp->next;
    }

    freeVehicleList(copyHead);  // Free the copied list
}

// Function to split the parking space linked list into two halves
struct ParkingSpace* splitParking(struct ParkingSpace* head) {
    struct ParkingSpace* slow = head;
    struct ParkingSpace* fast = head->next;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    struct ParkingSpace* mid = slow->next;
    slow->next = NULL;
    return mid;
}

// Function to merge two sorted linked lists based on occupancy
struct ParkingSpace* mergeParkingOccupancy(struct ParkingSpace* left, struct ParkingSpace* right) {
    if (!left) return right;
    if (!right) return left;

    struct ParkingSpace* result = NULL;
    
    if (left->occupancy > right->occupancy) {  // Sorting in descending order
        result = left;
        result->next = mergeParkingOccupancy(left->next, right);
    } else {
        result = right;
        result->next = mergeParkingOccupancy(left, right->next);
    }
    
    return result;
}

// Merge Sort function for sorting parking spaces by occupancy
struct ParkingSpace* mergeSortParkingOccupancy(struct ParkingSpace* head) {
    if (!head || !head->next) {
        return head;  // Base case: 0 or 1 elements
    }

    struct ParkingSpace* mid = splitParking(head);
    struct ParkingSpace* left = mergeSortParkingOccupancy(head);
    struct ParkingSpace* right = mergeSortParkingOccupancy(mid);

    return mergeParkingOccupancy(left, right);
}

// Wrapper function to sort parking spaces by occupancy and display the sorted list
void sortAndDisplayParkingByOccupancy() {
    struct ParkingSpace* copyHead = copyParkingList(parkingHead);  // Create a copy of the main list
    if (!copyHead) {
        printf("Failed to create a copy of the parking list.\n");
        return;
    }

    copyHead = mergeSortParkingOccupancy(copyHead);  // Sort the copied list

    printf("\nSorted Parking Spaces by Occupancy (Copy):\n");
    struct ParkingSpace* temp = copyHead;
    while (temp) {
        printf("Space ID: %d | Occupancy: %d\n", temp->spaceID, temp->occupancy);
        temp = temp->next;
    }

    // Free the copied list to prevent memory leaks
    freeParkingList(copyHead);
    
}

// Function to merge two sorted linked lists based on revenue
struct ParkingSpace* mergeParkingRevenue(struct ParkingSpace* left, struct ParkingSpace* right) {
    if (!left) return right;
    if (!right) return left;

    struct ParkingSpace* result = NULL;
    
    if (left->revenueGenerated > right->revenueGenerated) {  // Sorting in descending order
        result = left;
        result->next = mergeParkingRevenue(left->next, right);
    } else {
        result = right;
        result->next = mergeParkingRevenue(left, right->next);
    }
    
    return result;
}

// Merge Sort function for sorting parking spaces by revenue
struct ParkingSpace* mergeSortParkingRevenue(struct ParkingSpace* head) {
    if (!head || !head->next) {
        return head;  // Base case: 0 or 1 elements
    }

    struct ParkingSpace* mid = splitParking(head);
    struct ParkingSpace* left = mergeSortParkingRevenue(head);
    struct ParkingSpace* right = mergeSortParkingRevenue(mid);

    return mergeParkingRevenue(left, right);
}

// Wrapper function to sort parking spaces by revenue and display the sorted list
void sortAndDisplayParkingByRevenue() {
    struct ParkingSpace* copyHead = copyParkingList(parkingHead);  // Use global parkingHead directly
    if (!copyHead) {
        printf("Failed to create a copy of the parking list.\n");
        return;
    }

    copyHead = mergeSortParkingRevenue(copyHead);  // Sort the copy

    printf("\nSorted Parking Spaces by Revenue (Copy):\n");
    struct ParkingSpace* temp = copyHead;
    while (temp) {
        printf("Space ID: %d | Revenue: %.2f\n", temp->spaceID, temp->revenueGenerated);
        temp = temp->next;
    }

    // Free the copied list to prevent memory leaks
    freeParkingList(copyHead);
    
}


// Function to display parking space details
void displayParkingSpaces() {
    struct ParkingSpace* temp = parkingHead;
    while (temp != NULL) {
        printf("Space ID: %d | Occupied: %d | Revenue: %.2f | Occupancy: %d\n", temp->spaceID, temp->isOccupied, temp->revenueGenerated, temp->occupancy);
        temp = temp->next;
    }
}

// Function to display all parked vehicles
void displayVehicles() {
    struct Vehicle* temp = vehicleHead;
    while (temp != NULL) {
        printf("Vehicle: %s | Owner: %s | Parking ID: %d | Total Hours: %.2f | Revenue: %.2f | Parkings: %d\n", temp->vehicle_number, temp->owner_name, temp->parkingID, temp->totalparking_hours, temp->Revenue, temp->no_of_Parking);
        temp = temp->next;
    }
}

// Function to free allocated memory for both linked lists
void freeMemory() {
    struct Vehicle* vTemp;
    while (vehicleHead != NULL) {
        vTemp = vehicleHead;
        vehicleHead = vehicleHead->next;
        free(vTemp);
    }
    struct ParkingSpace* pTemp;
    while (parkingHead != NULL) {
        pTemp = parkingHead;
        parkingHead = parkingHead->next;
        free(pTemp);
    }
}

int main() {
    initializeParkingSpaces();
    loadVehicleDataFromFile();
    loadParkingSpaceDataFromFile();
    int choice;
    char vehicleNumber[20];
    char ownerName[100];

    do {
        printf("\n1. Park Vehicle\n2. Exit Vehicle\n3. Display Vehicles\n4. Display Parking Spaces\n5. Sort the list of vehicles based on number of parkings done.\n6. Sort the list of vehicles based on parking amount paid.\n7. Sort Parking Spaces by Occupancy\n8. Sort Parking Spaces by Revenue\n9. Exit\nEnter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter Vehicle Number: ");
                scanf("%s", vehicleNumber);
                if (!findVehicle(vehicleNumber)) {
                    printf("Enter Owner Name: ");
                    scanf(" %s", ownerName);
                } else {
                    strcpy(ownerName, findVehicle(vehicleNumber)->owner_name);
                }
                parkVehicle(vehicleNumber, ownerName);
                break;
                
            case 2:
                printf("Enter Vehicle Number: ");
                scanf("%s", vehicleNumber);
                exitVehicle(vehicleNumber);
                break;

            case 3:
                displayVehicles();
                break;

            case 4:
                displayParkingSpaces();
                break;

            case 5:
                // Sort the list of vehicles based on number of parkings done.
                sortVehiclesByParkingCount();         
                break;

            case 6:
                // Sort the list of vehicles based on total parking amount paid.
                sortAndDisplayVehiclesByRevenue();           
                break;

            case 7:
                // Sort the list of parking spaces based on their occupancy.
                sortAndDisplayParkingByOccupancy();
                break;

            case 8:
                // Sort the list of parking spaces which generated maximum revenue.
                sortAndDisplayParkingByRevenue();
                break;

            case 9:
                printf("Exiting program.\n");
                freeMemory();
                break;

            default:
                printf("Invalid choice.\n");
        }
    } while (choice != 9);
    
    return 0;
}
